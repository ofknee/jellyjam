<canvas 
  id="waterCanvas" 
  class="fixed inset-0 w-full h-full pointer-events-none" 
  style="z-index: -1; background: transparent; filter: blur(8px); transform: scale(1.05);"
></canvas>

<script is:inline>
document.addEventListener('DOMContentLoaded', () => {
  const canvas = document.getElementById('waterCanvas');
  if (!canvas) return;
  const ctx = canvas.getContext('2d');
  if (!ctx) return;

  const res = 10; // smaller = higher resolution
  let width, height, capacity;
  let buffer1, buffer2;
  const damping = 0.96; // higher = longer waves

  function init() {
    width = Math.floor(window.innerWidth / res);
    height = Math.floor(window.innerHeight / res);
    capacity = width * height;
    canvas.width = width;
    canvas.height = height;
    buffer1 = new Int32Array(capacity).fill(0);
    buffer2 = new Int32Array(capacity).fill(0);
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
  }

  // --- Edge-only ripple injection ---
  function splashRect(rect, strength = 100) {
    const left   = Math.floor(rect.left / res);
    const right  = Math.floor(rect.right / res);
    const top    = Math.floor(rect.top / res);
    const bottom = Math.floor(rect.bottom / res);

    // Top + Bottom edges
    for (let x = left; x <= right; x++) {
      if (top > 0 && top < height) buffer2[top*width + x] += strength;
      if (bottom > 0 && bottom < height) buffer2[bottom*width + x] += strength;
    }

    // Left + Right edges
    for (let y = top; y <= bottom; y++) {
      if (left > 0 && left < width) buffer2[y*width + left] += strength;
      if (right > 0 && right < width) buffer2[y*width + right] += strength;
    }
  }

  // --- Mouse “drag ripple” ---
  let lastMouseX = -1;
  let lastMouseY = -1;
  function disturb(x, y) {
    if (lastMouseX === -1) {
      lastMouseX = x;
      lastMouseY = y;
      return;
    }
    const dx = x - lastMouseX;
    const dy = y - lastMouseY;
    const distance = Math.sqrt(dx*dx + dy*dy);
    const steps = Math.max(Math.floor(distance / res), 1);
    for (let i = 0; i < steps; i++) {
      const cx = Math.floor((lastMouseX + dx * (i/steps)) / res);
      const cy = Math.floor((lastMouseY + dy * (i/steps)) / res);
      if (cx > 0 && cx < width && cy > 0 && cy < height) {
        buffer2[cy*width + cx] += 50;
      }
    }
    lastMouseX = x;
    lastMouseY = y;
  }

  // --- Simulation update ---
  function update() {
    const img = ctx.createImageData(width, height);
    const data = img.data;

    for (let i = width; i < capacity - width; i++) {
      buffer2[i] = ((buffer1[i-1]+buffer1[i+1]+buffer1[i-width]+buffer1[i+width])>>1) - buffer2[i];
      buffer2[i] *= damping;

      const val = Math.abs(buffer2[i]);
      if (val > 0.5) {
        const pos = i*4;
        data[pos] = 1;      // R
        data[pos+1] = 205;  // G
        data[pos+2] = 254;  // B
        data[pos+3] = Math.min(255, val); // A
      }
    }

    ctx.putImageData(img, 0, 0);
    
    [buffer1, buffer2] = [buffer2, buffer1];
    requestAnimationFrame(update);
  }

  // --- Mouse events ---
  window.addEventListener('mousemove', e => disturb(e.clientX, e.clientY));

  // --- Scroll displacement ---
  let lastScrollY = window.scrollY;
  function shiftBuffers(deltaY) {
    const shift = Math.floor(deltaY / res);
    if (shift === 0) return;
  
    const absShift = Math.abs(shift);
    const rowSize = width;
  
    if (shift > 0) {
      // Scrolling Down: Move data UP in the array
      const moveAmount = (height - absShift) * rowSize;
      const offset = absShift * rowSize;
      
      // We use .set() because it is much faster than a manual 'for' loop
      buffer1.set(buffer1.subarray(offset, offset + moveAmount), 0);
      buffer2.set(buffer2.subarray(offset, offset + moveAmount), 0);
      
      // Clear the "new" rows at the bottom
      buffer1.fill(0, moveAmount);
      buffer2.fill(0, moveAmount);
    } else {
      // Scrolling Up: Move data DOWN in the array
      const moveAmount = (height - absShift) * rowSize;
      const offset = absShift * rowSize;
      
      buffer1.set(buffer1.subarray(0, moveAmount), offset);
      buffer2.set(buffer2.subarray(0, moveAmount), offset);
      
      // Clear the "new" rows at the top
      buffer1.fill(0, 0, offset);
      buffer2.fill(0, 0, offset);
    }
  }
  window.addEventListener('scroll', () => {
    const delta = window.scrollY - lastScrollY;
    shiftBuffers(delta);
    lastScrollY = window.scrollY;
  }, {passive:true});

  window.addEventListener('resize', init);

  // --- Attach .water-solid interactions ---
  function bindWaterSolid() {
    document.querySelectorAll('.water-solid').forEach(el => {
      el.addEventListener('mouseenter', () => splashRect(el.getBoundingClientRect(), 80));
      el.addEventListener('click', () => splashRect(el.getBoundingClientRect(), 120));
    });
  }

  init();
  bindWaterSolid();
  update();
});
</script>

